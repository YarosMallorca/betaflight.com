"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7611],{7246:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>n,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>h});var i=o(85893),s=o(11151);const a={},n="Feed Forward 2.0",r={id:"wiki/archive/Feed-Forward-2.0",title:"Feed Forward 2.0",description:"Betaflight 4.1 brings us Feed Forward 2.0 - a comprehensive set of updates to FeedForward.",source:"@site/docs/wiki/archive/Feed-Forward-2.0.md",sourceDirName:"wiki/archive",slug:"/wiki/archive/Feed-Forward-2.0",permalink:"/docs/wiki/archive/Feed-Forward-2.0",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"wiki",previous:{title:"Failsafe",permalink:"/docs/wiki/archive/Failsafe-(Flight-Controller)"},next:{title:"Flight Controller Gyro Orientation",permalink:"/docs/wiki/archive/Flight-Controller-Gyro-Orientation"}},l={},h=[{value:"What is FeedForward?",id:"what-is-feedforward",level:2},{value:"ff_boost",id:"ff_boost",level:2},{value:"ff_interpolate_sp",id:"ff_interpolate_sp",level:2},{value:"ff_max_rate_limit",id:"ff_max_rate_limit",level:2},{value:"ff_interpolate_sp = AVERAGED",id:"ff_interpolate_sp--averaged",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"feed-forward-20",children:"Feed Forward 2.0"}),"\n",(0,i.jsxs)(t.p,{children:["Betaflight 4.1 brings us ",(0,i.jsx)(t.code,{children:"Feed Forward 2.0"})," - a comprehensive set of updates to FeedForward."]}),"\n",(0,i.jsxs)(t.p,{children:["Note that ",(0,i.jsx)(t.code,{children:"ff_spread"})," from the development versions has been changed to ",(0,i.jsx)(t.code,{children:"set ff_interpolate_sp = AVERAGED"}),". The time interval to spread is no longer required."]}),"\n",(0,i.jsx)(t.h2,{id:"what-is-feedforward",children:"What is FeedForward?"}),"\n",(0,i.jsx)(t.p,{children:"FeedForward (FF) is a drive factor that increases stick responsiveness. It is proportional to the instantaneous derivative, or 'rate of change' of stick movement. The faster the sticks are moving, the more FeedForward we get. FeedForward helps P drive the quad into turns. Unlike P, FeedForward cannot cause oscillation, no matter how much FF is added."}),"\n",(0,i.jsx)(t.p,{children:"With FeedForward, we get better stick responsiveness without pushing P so high as to cause wobbles. It also reduces the delay time between input and response. Less delay means less error and less I windup/overshoot. It is great for racing, LOS and radical freestyle flying. It isn't great for cinematic HD."}),"\n",(0,i.jsx)(t.p,{children:"Too much FeedForward can cause:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"overshoot at the start of a flip, particularly when the sticks hit 100% travel"}),"\n",(0,i.jsx)(t.li,{children:"exaggerated responsiveness to RC steps"}),"\n",(0,i.jsx)(t.li,{children:"amplification of shaking when the pilot is cold or nervous"}),"\n",(0,i.jsx)(t.li,{children:"spikes in the motor traces and brief shakes with big RC steps"}),"\n",(0,i.jsx)(t.li,{children:"gyro getting ahead of setpoint"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Since RC data comes into the flight controller in 'packets', we actually get a series of sudden steps coming in. The derivative of an instant step is an infinitely high spike, which is basically useless. Back in 3.4.0 we introduced 'filter' mode RC smoothing, where an 'input' lowpass filter rounded off those steps; the derivative now became a wider spike that we could use. We then applied a 'derivative' lowpass over that spike, which smoothed it out into a kind of 'lump' of FF for each incoming step. AUTO RC filtering adapts the smoothing filters dynamically to the apparent incoming RC step rate; manual setups can be fine-tuned to any desired degree of smoothness, at the cost of input delay."}),"\n",(0,i.jsx)(t.p,{children:"Currently erratic RC steps are a major problem. OpenTx 2.3 improves on this a bit for FrSky users. TBS are introducing a 'locked 150hz mode' that may be better."}),"\n",(0,i.jsxs)(t.p,{children:["4.1 introduces several novel ",(0,i.jsx)(t.code,{children:"ff_2.0"})," technologies that improve on these limitations."]}),"\n",(0,i.jsx)(t.h2,{id:"ff_boost",children:"ff_boost"}),"\n",(0,i.jsx)(t.p,{children:"This is a fantastic new feature that markedly reduces delay in fast setpoint changes."}),"\n",(0,i.jsx)(t.p,{children:"Most motors take time to spin up / slow down. They need to be pushed harder at the very start of a move than in the middle. FF and P both ramp up slowly at the start of a move because initially our fingers move slowly and most pilots use Expo in their Rates setup. So until now, the motors haven't got that immediate push needed unless really high FF gains were used (250+). But with FF gains of that magnitude, overshoot is hard to control, especially because of SuperRate being applied at the end of the stick travel, really causing FF to boost the move right when we need the quad to start to slow down to not overshoot."}),"\n",(0,i.jsx)(t.p,{children:"'ff_boost' is a PID parameter that is proportional to the stick acceleration. Technically it is the second derivative of Setpoint."}),"\n",(0,i.jsxs)(t.p,{children:["Being the second derivative, ",(0,i.jsx)(t.code,{children:"ff_boost"})," peaks really early in a move, the instant the sticks start moving. It then eases away to zero when the sticks are at mid-travel, because at constant stick velocity we have lots of FF, but no acceleration. ff_boost finally goes negative as the sticks slow down."]}),"\n",(0,i.jsx)(t.p,{children:"The acceleration component does exactly what we need to help overcome motor delay - pushes early, eases off mid-move, and actively slows down the motors at the end. With the right amount of FF and ff_boost, a responsive quad can have nearly completely lag-free tracking of inputs and not get overshoot."}),"\n",(0,i.jsxs)(t.p,{children:["Typically ",(0,i.jsx)(t.code,{children:"set ff_boost = 15"}),", the default, is about right for most quads. Larger values may be used on low-authority quads or quads with motors that are slow to spool up. More than 40 would be unusual."]}),"\n",(0,i.jsx)(t.p,{children:"The strength of the boost is directly linked to the amount of FF set in the PIDs. Think of ff_boost as a 'factor' that modulates the timing of how your FF gets applied to the motors. More boost brings the FF on earlier."}),"\n",(0,i.jsx)(t.p,{children:"Advanced users who can log should do a test flight with fast twitchy inputs, quick left/right stabs, and look for the timing and amount of their FF signal. Ideally P should have little work left to do when the boost/FF components are correct."}),"\n",(0,i.jsx)(t.p,{children:"ff_boost can work without any other of the ff_2.0 features being active."}),"\n",(0,i.jsx)(t.h2,{id:"ff_interpolate_sp",children:"ff_interpolate_sp"}),"\n",(0,i.jsx)(t.p,{children:"This is a 'digital' way of calculating FF from each new RC 'step'. It gives a cleaner feedforward trace than with the old 'filter' method, with less delay."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"set ff_interpolate_sp = ON"})," analyses each new incoming RC data packet, and the calculated change in setpoint is converted to an immediate step up in FF. Each step up is held constant until the next RC data step arrives."]}),"\n",(0,i.jsx)(t.p,{children:"The sharp corner of the FF step can be smoothed according to the rc_smoothing_derivative lowpass filter frequency. This is set dynamically by default in AUTO mode, but can be manually overriden if desired. 120hz is a good smoothing value for a clean feed-forward trace. 20hz smoothes out traces with a fair bit of up and down; 10hz may be needed for very long range and cinematic quads where the large steps from 50hz mode and poor quality links can make the quad jerky in turns."}),"\n",(0,i.jsxs)(t.p,{children:["Dropped RC packets will normally cause sudden FF drops to zero. ",(0,i.jsx)(t.code,{children:"set ff_interpolate_sp = AVERAGE"})," is intended to help manage this specific issue. Alternatively, a low rc_smoothing_derivative filtering value can smooth the drops out a bit, at the cost of incoming RC delay."]}),"\n",(0,i.jsx)(t.h2,{id:"ff_max_rate_limit",children:"ff_max_rate_limit"}),"\n",(0,i.jsx)(t.p,{children:"ff_max_rate_limit attenuates / prevents FF induced overshoot at the start of a flip."}),"\n",(0,i.jsx)(t.p,{children:"When performing quick flips or rolls, the sticks typically stop suddenly when they hit the physical limit of their travel. With Expo and SuperRate applied to your Rates, the rate of increase in Setpoint is greatest just before the sticks stop. At this point in time, the quad itself is turning really fast and has a ton of rotational momentum. The Expo\\SuperRate effect means FF is absolutely massive too. All this, just before the sticks suddenly come to a grinding halt."}),"\n",(0,i.jsx)(t.p,{children:"Significant overshoot, even with a lot of D, is basically inevitable. In previous versions, you could use D_min to boost your D-gains high enough to compensate, but it was difficult to find the balance. Additionally, the transition would be sudden and the opposing pair of motors have to spin up and go full throttle, which in turn causes wobbles on the other axes and makes the quad climb. Using a ton of D to control this has its own problems, eg noise and dumbing down responsiveness at other times."}),"\n",(0,i.jsx)(t.p,{children:"ff_max_rate_limit predictively identifies situations in which the sticks are likely to hit their limit, and cuts FF in anticipation of that happening. It kind of 'looks ahead' and pre-emptively reduces FF just at the right time, typically totally eliminating the overshoot that would otherwise happen."}),"\n",(0,i.jsx)(t.p,{children:"A major benefit is that it markedly reduces the need for the opposing motors to spin up. Flips become cleaner and more accurate than before, and climb on flipping under LOS conditions is much less."}),"\n",(0,i.jsx)(t.p,{children:"The default value of 100 works well, and attempts to reach FF outputs of 0 as gyro values reach setpoint.\nLower values result in feedforward influence tapering to 0 at a percentage of those values (e.g. at a value of 50, in a sustained flip, once gyro reaches half the setpoint value the feedforward term will taper to zero). Higher values allow for feedforward to continue influencing the PID controller. For higher authority craft this will cause overshoot, but for authority-limited craft these higher values can be very beneficial.\nff_max_rate_limit is not active as the sticks return to centre."}),"\n",(0,i.jsx)(t.p,{children:"To determine ff_max_rate_limit and ff_boost works best, look at the start of a hard flip in BlackBox Explorer and see if there is any overshoot. If with ff_max_rate_limit = 100 there is still too much overshoot, first evaluate if Feedforward or P-term is driving overshoot at the time of interest. If so, try ff_max_rate_limit = 95. If the overshoot is too well controlled, try 105 to 110. The range of adjustment is quite tight."}),"\n",(0,i.jsx)(t.h2,{id:"ff_interpolate_sp--averaged",children:"ff_interpolate_sp = AVERAGED"}),"\n",(0,i.jsx)(t.p,{children:"Since FF is calculated for each incoming RC step, we have a problem when a new step doesn't arrive as it should."}),"\n",(0,i.jsx)(t.p,{children:"Usually this is caused by 'dropped packets', or when a TBS or R9 Rx switches out of 150hz mode to the slower 50hz mode. Anytime this happens, FF would normally drop suddenly to zero; when the next valid data value comes in, a double-height step up occurs. These zero/double-height pairs in the FF trace are very messy."}),"\n",(0,i.jsxs)(t.p,{children:["In ",(0,i.jsx)(t.code,{children:"AVERAGED"})," mode, the interpolation algorithm averages each two successive feed forward values. In the case of a sudden drop to zero with a large subsequent step up, this is is changed to a smaller drop, a middle value, and a jump up. Overall the steps are smaller."]}),"\n",(0,i.jsxs)(t.p,{children:["There is a downside to using ",(0,i.jsx)(t.code,{children:"AVERAGED"}),". If the pilot makes a fast input, then suddenly holds the sticks perfectly still, ff_spread will hold FF at the previous, high, value for the set time, rather than dropping to zero immediately as it should. This can cause an overshoot for the duration set by the extend value. It is most easily seen at the start of a flip when the sticks hit their physical limit, but can happen at other times."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"AVERAGED"})," is most useful for long-range / cinematic quads with substantial RC smoothing."]}),"\n",(0,i.jsx)(t.p,{children:"For racers and general use the quality of the RC link depends mostly on how good your antennas are and how far you plan to fly. Close-in racing with good antennas, especially with Futaba and some Spectrum radios that have very consistent RC steps, can work best without averaging."}),"\n",(0,i.jsxs)(t.p,{children:["For technical details and more info,check the ",(0,i.jsx)(t.a,{href:"https://github.com/betaflight/betaflight/pull/8623",children:"original pull request #8623"})]})]})}function c(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,t,o)=>{o.d(t,{Z:()=>r,a:()=>n});var i=o(67294);const s={},a=i.createContext(s);function n(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:n(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);