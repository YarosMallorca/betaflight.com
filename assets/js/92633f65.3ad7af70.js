"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6624],{79009:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>o,default:()=>x,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var r=n(85893),t=n(11151);const i={},o="Single Wire FlySky IBUS Telemetry",a={id:"wiki/guides/current/IBus-telemetry",title:"Single Wire FlySky IBUS Telemetry",description:"It's now possible to combine the serial rx and ibus telemetry on the same fc uart on a single pin.",source:"@site/docs/wiki/guides/current/IBus-telemetry.md",sourceDirName:"wiki/guides/current",slug:"/wiki/guides/current/IBus-telemetry",permalink:"/docs/wiki/guides/current/IBus-telemetry",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"wiki",previous:{title:"Iterm Relax explained",permalink:"/docs/wiki/guides/current/I-Term-Relax-Explained"},next:{title:"IRC Tramp",permalink:"/docs/wiki/guides/current/IRC-Tramp"}},d={},l=[{value:"Technical details:",id:"technical-details",level:2}];function c(e){const s={br:"br",code:"code",h1:"h1",h2:"h2",hr:"hr",img:"img",p:"p",pre:"pre",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h1,{id:"single-wire-flysky-ibus-telemetry",children:"Single Wire FlySky IBUS Telemetry"}),"\n",(0,r.jsx)(s.p,{children:"It's now possible to combine the serial rx and ibus telemetry on the same fc uart on a single pin."}),"\n",(0,r.jsx)(s.p,{children:"I'm combining the ibus ports of the FS-iA6B receiver with a diode and a resistor."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"+---------+\n| FS-iA6B |\n|         |\n| Ser RX  |---|<---\\       +------------+\n|         |        |       | FC         |\n| Sensor  |---[R]--*-------| Uart TX    |\n+---------+                +------------+\n"})}),"\n",(0,r.jsx)(s.p,{children:"R = 10Kohm, Diode 1N4148 or similar."}),"\n",(0,r.jsx)(s.p,{children:"Note (2018-07-27): In some cases, the value of the series resistor may be too large, and going down to 1K[ohm] may provide a good result."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{src:"https://cloud.githubusercontent.com/assets/6065378/23835685/0ed7bfc6-076c-11e7-9c27-dcf6b9686847.png",alt:"image"})}),"\n",(0,r.jsx)(s.p,{children:"Both uart tx and rx channels are used so it's not possible to use the spare pin for rx of something else."}),"\n",(0,r.jsx)(s.p,{children:"Configure the serial port like this to get both serial rx and ibus telemetry on the same port:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"serial 1 4160 115200 57600 115200 115200\n"})}),"\n",(0,r.jsx)(s.p,{children:"It is still possible to run the serial rx and ibus telemetry on two uarts like before, an example:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"serial 1 64 115200 57600 0 115200\nserial 2 4096 115200 57600 115200 115200\n"})}),"\n",(0,r.jsxs)(s.p,{children:["This is how the signals look:\n",(0,r.jsx)(s.img,{src:"https://cloud.githubusercontent.com/assets/6065378/23835770/5dd5c9f0-076d-11e7-84eb-486759996cd2.png",alt:"image"})]}),"\n",(0,r.jsx)(s.h2,{id:"technical-details",children:"Technical details:"}),"\n",(0,r.jsx)(s.p,{children:"Ibus Telemetry is a half-duplex serial protocol. It shares 1 line for\nboth TX and RX. It runs at a fixed baud rate of 115200. Queries are sent\nevery 7ms by the iBus receiver. Multiple sensors can be daisy chained with\nibus but this is implemented but not tested because i don't have one of the\nsensors to test with"}),"\n",(0,r.jsx)(s.hr,{}),"\n",(0,r.jsxs)(s.p,{children:["/       \\                                             /---------",(0,r.jsx)(s.br,{}),"\n","| STM32 |--UART TX--\x3e[Bi-directional @ 115200 baud]<--| IBUS RX |\n|  uC   |--UART RX--x[not connected]                  ---------/\n_______/"]}),"\n",(0,r.jsx)(s.p,{children:"The protocol is driven by the iBus receiver, currently either an IA6B or\nIA10. All iBus traffic is little endian. It begins with the iBus rx\nquerying for a sensor on the iBus:"}),"\n",(0,r.jsxs)(s.p,{children:["/---------",(0,r.jsx)(s.br,{}),"\n","| IBUS RX | > Hello sensor at address 1, are you there?\n---------/     [ 0x04, 0x81, 0x7A, 0xFF ]"]}),"\n",(0,r.jsx)(s.p,{children:"0x04       - Packet Length\n0x81       - bits 7-4 Command (1000 = discover sensor)\nbits 3-0 Address (0001 = address 1)\n0x7A, 0xFF - Checksum, 0xFFFF - (0x04 + 0x81)"}),"\n",(0,r.jsx)(s.p,{children:"Due to the daisy-chaining, this hello also serves to inform the sensor\nof its address (position in the chain). There are 16 possible addresses\nin iBus, however address 0 is reserved for the rx's internally measured\nvoltage leaving 0x1 to 0xF remaining."}),"\n",(0,r.jsx)(s.p,{children:"Having learned it's address, the sensor simply echos the message back:"}),"\n",(0,r.jsxs)(s.p,{children:["/--------",(0,r.jsx)(s.br,{}),"\n","Yes, i'm here, hello! < | Sensor |\n[ 0x04, 0x81, 0x7A, 0xFF ]     --------/"]}),"\n",(0,r.jsx)(s.p,{children:"0x04, 0x81, 0x7A, 0xFF - Echo back received packet"}),"\n",(0,r.jsx)(s.p,{children:"On receipt of a response, the iBus rx next requests the sensor's type:"}),"\n",(0,r.jsxs)(s.p,{children:["/---------",(0,r.jsx)(s.br,{}),"\n","| IBUS RX | > Sensor at address 1, what type are you?\n---------/     [ 0x04, 0x91, 0x6A, 0xFF ]"]}),"\n",(0,r.jsx)(s.p,{children:"0x04       - Packet Length\n0x91       - bits 7-4 Command (1001 = request sensor type)\nbits 3-0 Address (0001 = address 1)\n0x6A, 0xFF - Checksum, 0xFFFF - (0x04 + 0x91)"}),"\n",(0,r.jsx)(s.p,{children:"To which the sensor responds with its details:"}),"\n",(0,r.jsxs)(s.p,{children:["/--------",(0,r.jsx)(s.br,{}),"\n","Yes, i'm here, hello! < | Sensor |\n[ 0x06 0x91 0x00 0x02 0x66 0xFF ]     --------/"]}),"\n",(0,r.jsx)(s.p,{children:"0x06       - Packet Length\n0x91       - bits 7-4 Command (1001 = request sensor type)\nbits 3-0 Address (0001 = address 1)\n0x00       - Measurement type (0 = internal voltage)\n0x02       - Unknown, always 0x02\n0x66, 0xFF - Checksum, 0xFFFF - (0x06 + 0x91 + 0x00 + 0x02)"}),"\n",(0,r.jsx)(s.p,{children:"The iBus rx continues the discovery process by querying the next\naddress. Discovery stops at the first address which does not respond."}),"\n",(0,r.jsx)(s.p,{children:"The iBus rx then begins a continual loop, requesting measurements from\neach sensor discovered:"}),"\n",(0,r.jsxs)(s.p,{children:["/---------",(0,r.jsx)(s.br,{}),"\n","| IBUS RX | > Sensor at address 1, please send your measurement\n---------/     [ 0x04, 0xA1, 0x5A, 0xFF ]"]}),"\n",(0,r.jsx)(s.p,{children:"0x04       - Packet Length\n0xA1       - bits 7-4 Command (1010 = request measurement)\nbits 3-0 Address (0001 = address 1)\n0x5A, 0xFF - Checksum, 0xFFFF - (0x04 + 0xA1)"}),"\n",(0,r.jsxs)(s.p,{children:["/--------",(0,r.jsx)(s.br,{}),"\n","I'm reading 0 volts < | Sensor |\n[ 0x06 0xA1 0x00 0x00 0x5E 0xFF ]     --------/"]}),"\n",(0,r.jsx)(s.p,{children:"0x06       - Packet Length\n0xA1       - bits 7-4 Command (1010 = request measurement)\nbits 3-0 Address (0001 = address 1)\n0x00, 0x00 - The measurement\n0x58, 0xFF - Checksum, 0xFFFF - (0x06 + 0xA1 + 0x00 + 0x00)"}),"\n",(0,r.jsx)(s.p,{children:"Due to the limited telemetry data types possible with ibus, we\nsimply send everything which can be represented. Currently this\nis voltage and temperature and throttle value."})]})}function x(e={}){const{wrapper:s}={...(0,t.a)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},11151:(e,s,n)=>{n.d(s,{Z:()=>a,a:()=>o});var r=n(67294);const t={},i=r.createContext(t);function o(e){const s=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:s},e.children)}}}]);