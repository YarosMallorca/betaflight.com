"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9979],{36576:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var t=r(85893),i=r(11151);const a={},s="Atomic Barrier implementation",o={id:"development/Atomic-Barrier",title:"Atomic Barrier implementation",description:"The ATOMICBLOCK/ATOMICBARRIER construction is dependent on gcc extensions. I relies on gcc cleanup function (attribute ((cleanup))) and assumes that cleanup handler is called, when leaving block, even when associated variable is eliminated.",source:"@site/docs/development/Atomic-Barrier.md",sourceDirName:"development",slug:"/development/Atomic-Barrier",permalink:"/docs/development/Atomic-Barrier",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"development",previous:{title:"MDX Reference",permalink:"/docs/development/mdx-reference"},next:{title:"Battery Monitoring",permalink:"/docs/development/Battery"}},c={},d=[];function m(e){const n={code:"code",h1:"h1",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"atomic-barrier-implementation",children:"Atomic Barrier implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'static int markme_bar = 0;\nstatic int markme = 0;\n\nmarkme++;\n// (1) markme is read into register, but not changed\nmarkme_bar++;\n// markme_bar is read from memory and incremented\nATOMIC_BLOCK_NB(NVIC_PRIO_TIMER) {\n   ATOMIC_BARRIER(markme_bar);\n// start of ATOMIC_BLOCK_NB scope:\n//  markme_bar is stored into memory (it is input/output - "+m" output operand - of asm volatile)\n//  BASEPRI is saved into temporary variable\n//  BASEPRI_MAX is decremented to NVIC_PRIO_TIMER (if it is higher than NVIC_PRIO_TIMER or zero; lower number means higher priority on ARM)\n   markme++;\n// nothing happens, markme value is not needed yet\n   markme_bar++;\n// (2) markme_bar re-read from memory (ATOMIC_BARRIER marked it as modified - "+m" output operand of asm volatile)\n//  and incremented\n\n// end of ATOMIC_BLOCK_NB scope:\n//  markme_bar is stored into memory (cleanup function from ATOMIC_BARRIER) / input "m" operand), but kept for later use in register\n//    (actually markme_bar+1 is stored and pre-increment value kept in register)\n// BASEPRI value is restored\n};\n\nmarkme++;\n// register value read in (1) is incremented by 3\nmarkme_bar++;\n// register value read in (2) is incremented (actually +=2, because register contains pre-increment value)\n\n// markme and markme_bar are stored into memory\n'})}),"\n",(0,t.jsx)(n.h1,{id:"atomic-barrier-warning",children:"Atomic Barrier Warning"}),"\n",(0,t.jsxs)(n.p,{children:["The ATOMIC_BLOCK/ATOMIC_BARRIER construction is dependent on gcc extensions. I relies on gcc cleanup function (",(0,t.jsx)(n.code,{children:"attribute ((cleanup))"}),") and assumes that cleanup handler is called, when leaving block, even when associated variable is eliminated."]}),"\n",(0,t.jsx)(n.p,{children:"There is (a bit paranoid) safeguard warning to make sure that generated assembly is hand-checked on new gcc version. It is assumed that only major gcc version versions need to be checked."}),"\n",(0,t.jsx)(n.p,{children:"If GCC is upgraded and a warning appears when compiling then the generated asm source must be verified."}),"\n",(0,t.jsx)(n.p,{children:"e.g."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'%% serial_softserial.c\nwarning "Please verify that ATOMIC_BARRIER works as intended"\n'})}),"\n",(0,t.jsx)(n.p,{children:"To perform the verification, proceed as per discusson on issue #167 which reads:"}),"\n",(0,t.jsx)(n.p,{children:"I hope it's enough to check that optimized-away variable still has cleanup code at end of scope."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"static int markme=0;\nmarkme++;\nATOMIC_BLOCK_NB(0xff) {\n   ATOMIC_BARRIER(markme);\n   markme++;\n};\nmarkme++;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["pass ",(0,t.jsx)(n.code,{children:"-save-temps=obj"})," (or ",(0,t.jsx)(n.code,{children:"-save-temps=cwd"}),", but lots of files will end up in same directory as makefile) to gcc link step (LTO is in use), find resulting ",(0,t.jsx)(n.code,{children:"*.ltrans*.ltrans.s"})," (grep for ",(0,t.jsx)(n.code,{children:"markme"}),", on linux it ends up in ",(0,t.jsx)(n.code,{children:"/tmp"}),") and check that generated assembly sequence is:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"                 MSR basepri_max, r3\n# (possibly markme address load)\n                # barier (markme) start\n\n# (increment markme, load and store to memory)\n        ldr     r2, [r3]\n        adds    r0, r2, #1\n        str     r0, [r3]\n\n                # barier(markme)  end\n                MSR basepri, r3\n\n# (markme value should be cached in register on next increment)\n"})}),"\n",(0,t.jsx)(n.p,{children:"The # barrier(markme) must surround access code and must be inside MSR basepri instructions ."}),"\n",(0,t.jsx)(n.p,{children:"Similar approach is used for ATOMIC_BLOCK in avr libraries, so gcc should not break this behavior."}),"\n",(0,t.jsx)(n.p,{children:"IMO attribute(cleanup) and asm volatile is defined in a way that should guarantee this."}),"\n",(0,t.jsx)(n.p,{children:"attribute(cleanup) is probably safer way to implement atomic sections - another possibility is to explicitly place barriers in code, but that can (and will eventually) lead to missed barrier/basepri restore on same path creating very hard to find bug."}),"\n",(0,t.jsx)(n.p,{children:"The 'MEMORY_BARRIER()' code can be omitted when 'ATOMIC_BLOCK' (with full memory barriers) is used, but it is better to explicitly state what memory is protected by barrier. gcc 5 can use this knowledge to greatly improve generated code."})]})}function l(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>o,a:()=>s});var t=r(67294);const i={},a=t.createContext(i);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);