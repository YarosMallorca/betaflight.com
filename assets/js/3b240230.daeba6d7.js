"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6221],{82677:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>a});var s=r(85893),n=r(11151);const o={},l="EXST bootloader",i={id:"development/EXST-Bootloader",title:"EXST bootloader",description:"The EXST (External Storage) system requires that the targets' CPU has a small program, called a bootloader, that provides functionality to load firmware from an external storage into the CPU's RAM so that the firmware can be executed.",source:"@site/docs/development/EXST-Bootloader.md",sourceDirName:"development",slug:"/development/EXST-Bootloader",permalink:"/docs/development/EXST-Bootloader",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"development",previous:{title:"What is DSHOT?",permalink:"/docs/development/Dshot"},next:{title:"Betaflight Flight Controller LED usage",permalink:"/docs/development/FC-LEDs"}},d={},a=[{value:"EXST format",id:"exst-format",level:2},{value:"EXST bootloader block",id:"exst-bootloader-block",level:2},{value:"Block Format 0x00 Content",id:"block-format-0x00-content",level:3},{value:"Example possible future enhancements for the EXST bootloader block",id:"example-possible-future-enhancements-for-the-exst-bootloader-block",level:3}];function h(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"exst-bootloader",children:"EXST bootloader"}),"\n",(0,s.jsx)(t.p,{children:"The EXST (External Storage) system requires that the targets' CPU has a small program, called a bootloader, that provides functionality to load firmware from an external storage into the CPU's RAM so that the firmware can be executed."}),"\n",(0,s.jsx)(t.p,{children:"Example external storage systems include:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"External Flash using Firmware Partition"}),"\n",(0,s.jsx)(t.li,{children:"File on an SD card."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"EXST targets also have the requirement of providing a mechansim to load and save configuration ('eeprom'). options for this include:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"CPU Embedded flash page."}),"\n",(0,s.jsx)(t.li,{children:"External Flash using Config Partition"}),"\n",(0,s.jsx)(t.li,{children:"File on an SD card."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Since external storage systems can become corrupted, and communication errors can occur, Bootloaders should verify correct loading of the firmware from an external storage system, or after transferring via a debugger. An hash is provided for this purpose."}),"\n",(0,s.jsx)(t.p,{children:"Bootloaders are not limited to just one storage system."}),"\n",(0,s.jsx)(t.p,{children:"Bootloaders may offer additional functionality, such as:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"a means to update the firmware on an external storage medium (e.g. via DFU)"}),"\n",(0,s.jsx)(t.li,{children:"update one external storage system from another (i.e. update external flash from file on SD card)"}),"\n",(0,s.jsx)(t.li,{children:"backup, select, swap or erase firmware"}),"\n",(0,s.jsx)(t.li,{children:"backup, select, swap or erase configuration."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Users should consult the manual that came with their EXST bootloader-equipped flight controller for details on how to use any such features."}),"\n",(0,s.jsx)(t.p,{children:"The build system provides a way to build files suitable for transferring onto an external storage medium via the standard 'bin'/'hex' make goals."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"make TARGET=<targetname>\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This results in the usual ",(0,s.jsx)(t.code,{children:"*.bin"})," and ",(0,s.jsx)(t.code,{children:"*.hex"})," files and also a ",(0,s.jsx)(t.code,{children:"*_EXST.elf"})," file which have been patched to contain information required for bootloader operation."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:".bin"})," file is a binary file which should be transferred to the storage medium and is suitable for distribution.\nThe ",(0,s.jsx)(t.code,{children:".hex"})," file is a hex file which can be used by tools for uploading to a bootloader and is suitable for distribution."]}),"\n",(0,s.jsxs)(t.p,{children:["For developers there is a ",(0,s.jsx)(t.code,{children:"_EXST.elf"})," file which is a standard ",(0,s.jsx)(t.code,{children:".elf"})," file that has had one section replaced, this file is suitable for uploading to targets using a debugger such as GDB."]}),"\n",(0,s.jsx)(t.p,{children:"For details on the memory sections used refer to the linker files."}),"\n",(0,s.jsx)(t.h2,{id:"exst-format",children:"EXST format"}),"\n",(0,s.jsx)(t.p,{children:"The format for EXST targets is as follows:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Firmware."}),"\n",(0,s.jsx)(t.li,{children:"Bootloader block."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The bootloader block is 64 bytes."}),"\n",(0,s.jsxs)(t.p,{children:["For example a 448K EXST ",(0,s.jsx)(t.code,{children:".bin"})," file is comprised as follows:"]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Start Address"}),(0,s.jsx)(t.th,{children:"End address"}),(0,s.jsx)(t.th,{children:"Usage"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"0x00000"}),(0,s.jsx)(t.td,{children:"0x6FFBF"}),(0,s.jsx)(t.td,{children:"Firmware section"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"0x6FFC0"}),(0,s.jsx)(t.td,{children:"0x6FFFF"}),(0,s.jsx)(t.td,{children:"Bootloader block"})]})]})]}),"\n",(0,s.jsx)(t.h2,{id:"exst-bootloader-block",children:"EXST bootloader block"}),"\n",(0,s.jsx)(t.p,{children:"The bootloader block is comprised as follows:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Start Address"}),(0,s.jsx)(t.th,{children:"End address"}),(0,s.jsx)(t.th,{children:"Usage"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"0x00"}),(0,s.jsx)(t.td,{children:"0x00"}),(0,s.jsx)(t.td,{children:"Block Format"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"0x01"}),(0,s.jsx)(t.td,{children:"0x3F"}),(0,s.jsx)(t.td,{children:"Block Content"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"Block Formats"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Value"}),(0,s.jsx)(t.th,{children:"Meaning"})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"0x00"}),(0,s.jsx)(t.td,{children:"Block format 0x00"})]})})]}),"\n",(0,s.jsx)(t.h3,{id:"block-format-0x00-content",children:"Block Format 0x00 Content"}),"\n",(0,s.jsx)(t.p,{children:"Note: addresses relative to start of bootloader block"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Start Address"}),(0,s.jsx)(t.th,{children:"End address"}),(0,s.jsx)(t.th,{children:"Usage"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"0x01"}),(0,s.jsx)(t.td,{children:"0x01"}),(0,s.jsx)(t.td,{children:"Checksum/Hash method"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"0x02"}),(0,s.jsx)(t.td,{children:"0x2F"}),(0,s.jsx)(t.td,{children:"Reserved, fill with 0x00"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"0x30"}),(0,s.jsx)(t.td,{children:"0x3F"}),(0,s.jsx)(t.td,{children:"Checksum value, pad with trailing 0x00"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"Checksum Hash methods"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Value"}),(0,s.jsx)(t.th,{children:"Meaning"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"0x00"}),(0,s.jsx)(t.td,{children:"No checksum."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"0x01"}),(0,s.jsx)(t.td,{children:"MD5."})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"Checksum locations:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Start Address"}),(0,s.jsx)(t.th,{children:"End address"}),(0,s.jsx)(t.th,{children:"Usage"})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"0x30"}),(0,s.jsx)(t.td,{children:"0x3F"}),(0,s.jsx)(t.td,{children:"MD5 hash of firmware section"})]})})]}),"\n",(0,s.jsx)(t.p,{children:"The bootloader should make no attempt to use any reserved area otherwise this prevents it's future use by the firmware."}),"\n",(0,s.jsx)(t.p,{children:"The bootloader should ensure this block is in RAM when the firmware is loaded. i.e. copy the entire EXST image."}),"\n",(0,s.jsx)(t.p,{children:"As the reserved area is under control of the build system, not the bootloader, additional information can stored there for use by the firmware or future bootloaders. Extreme care must be taken not to break the bootloaders ability to load firmware. Consultation with the developers for any changes to this area is required."}),"\n",(0,s.jsx)(t.h3,{id:"example-possible-future-enhancements-for-the-exst-bootloader-block",children:"Example possible future enhancements for the EXST bootloader block"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Hardware layout identification - to allow the firmware to identify the hardware, such that IO pins and peripherals can be reserved/initialised."}),"\n",(0,s.jsx)(t.li,{children:"Alternative hashes/CRCs."}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},11151:(e,t,r)=>{r.d(t,{Z:()=>i,a:()=>l});var s=r(67294);const n={},o=s.createContext(n);function l(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);