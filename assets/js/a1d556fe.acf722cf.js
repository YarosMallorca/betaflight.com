"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4229],{73395:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>n,metadata:()=>r,toc:()=>h});var o=i(85893),s=i(11151);const n={},a="What is DSHOT?",r={id:"development/Dshot",title:"What is DSHOT?",description:"DSHOT is the name coined for a new digital ESC protocol by Felix (KISS) who is working in collaboration with Boris and the rest of the betaflight team, and Steffen (BLHeli) is also playing his part and introducing this protocol to BLHeli_S.",source:"@site/docs/development/Dshot.md",sourceDirName:"development",slug:"/development/Dshot",permalink:"/docs/development/Dshot",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"development",previous:{title:"Display",permalink:"/docs/development/Display"},next:{title:"EXST bootloader",permalink:"/docs/development/EXST-Bootloader"}},l={},h=[{value:"What is the difference to current protocols?",id:"what-is-the-difference-to-current-protocols",level:3},{value:"What is in a name?",id:"what-is-in-a-name",level:3},{value:"What are the technical details?",id:"what-are-the-technical-details",level:3},{value:"dshot-sequence",id:"dshot-sequence",level:3},{value:"dshot-output",id:"dshot-output",level:3},{value:"dshot-capture",id:"dshot-capture",level:3},{value:"Is it the most efficient?",id:"is-it-the-most-efficient",level:3},{value:"Will my ESCs or flight controller be supported?",id:"will-my-escs-or-flight-controller-be-supported",level:3},{value:"Ok \u2013 so what are the benefits?",id:"ok--so-what-are-the-benefits",level:3},{value:"Joe Lucid took it further and introduced bidirectional Dshot",id:"joe-lucid-took-it-further-and-introduced-bidirectional-dshot",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h3:"h3",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"what-is-dshot",children:"What is DSHOT?"}),"\n",(0,o.jsx)(t.p,{children:"DSHOT is the name coined for a new digital ESC protocol by Felix (KISS) who is working in collaboration with Boris and the rest of the betaflight team, and Steffen (BLHeli) is also playing his part and introducing this protocol to BLHeli_S."}),"\n",(0,o.jsx)(t.p,{children:"Make no mistake (despite what some have said) although this protocol uses the PWM (Pulse Width Modulation) features of the micro-controllers it is in fact digital. Each pulse represents a single bit. The timing of that pulse, as in the duration, in relation to the overall period between pulses dictates whether the bit is ON or OFF i.e. a bit value of a ZERO or a ONE. The micro-controllers are simply using the direct memory access, and timer capability within micro-controllers to generate the necessary signals on a motor pin so as to minimise the CPU utilisation."}),"\n",(0,o.jsx)(t.h3,{id:"what-is-the-difference-to-current-protocols",children:"What is the difference to current protocols?"}),"\n",(0,o.jsx)(t.p,{children:"Non-digital PWM protocols, such as Multishot, Oneshot42, Oneshot125 etc., simply rely on the width of the pulse to indicate throttle position. This has a number of significant drawbacks. In those analogue protocols subtle timing variations are a phenomenon we all know as jitter. This is where the signal jumps around the desired point. The shorter the pulse width the higher the likelihood and impact of this jitter. We have all seen an example of jitter in the receiver tab of the respective xFlight configurators. Variations in the pulse width also result in an unknown zero throttle, and an unknown maximum throttle. It is this reason that calibration of ESCs is required when using PWM."}),"\n",(0,o.jsx)(t.p,{children:"Pretty much all digital communications use timing and voltage levels against some form of reference (usually a ground) to indicate bit values. Serial (e.g. RS232, RS485 etc) uses the high (voltage > reference) to indicate a bit value of 1, and a low (voltage closely approximating reference or < reference) to represent a bit value of 0. In the case of serial each end of the communication needs to know the timing to utilise as consecutive bits in a 1 state are merely continuously highs (no pulses). The baud rate is therefore critical. In the case of DSHOT the timing is less critical. The reason for this is that the pulse width (duration) as a proportion of the total period denotes the bit value. This is very similar to the way in which WS2811/2 LED Strips work. In fact aside from the different timings, it would be pretty much identical."}),"\n",(0,o.jsx)(t.h3,{id:"what-is-in-a-name",children:"What is in a name?"}),"\n",(0,o.jsx)(t.p,{children:"For DSHOT600 the 600 signifies the bit-rate (in kilo-bits), so it can send 600 kilo-bits per second). For DSHOT300, and DSHOT150 it is essentially the same, but the bit-rate is slowed, for 300 (300 kilo-bits per second) it is 2x slower, for 150 (150 kilo-bits per second) it is 4 times slower. This means the timing above is simply x2 for 300, and x4 for 150. DSHOT300 and DSHOT150 were introduced to ensure that support for older less capable ESCs exists so flyers can get the benefit of digital accuracy."}),"\n",(0,o.jsx)(t.p,{children:"DSHOT bucks the trend, the higher number is faster than the lower numbers. The oneshot protocols (including Multishot) have used increasingly lower numbers to signify faster speeds."}),"\n",(0,o.jsx)(t.h3,{id:"what-are-the-technical-details",children:"What are the technical details?"}),"\n",(0,o.jsx)(t.p,{children:"For DSHOT600 the timing output is as follows:"}),"\n",(0,o.jsx)(t.h3,{id:"dshot-sequence",children:"dshot-sequence"}),"\n",(0,o.jsx)(t.p,{children:"Bit length (total timing period) is 1.67 microseconds (T0H + T0L or T1H + T1L).\nFor a bit to be 0, the pulse width is 625 nanoseconds (T0H \u2013 time the pulse is high for a bit value of ZERO)\nFor a bit to be 1, the pulse width is 1250 nanoseconds (T1H \u2013 time the pulse is high for a bit value of ONE)\nThe reason for the difference in pulse length for bit 0 and bit 1 values is that it allows for considerable tolerance in determining the value. So these timings can be off slightly and the result will still be the same."}),"\n",(0,o.jsx)(t.p,{children:"As with any protocol there needs to be a communication stream of bits, that will be interpreted for some outcome to occur. For the case of DSHOT the signal for a motor update consists of 16 bits (a frame). The first 11 bits are the actual throttle value. The next bit is to signal the ESC to provide a telemetry update (using a separate return channel), and the remaining 4 bits are a checksum."}),"\n",(0,o.jsx)(t.h3,{id:"dshot-output",children:"dshot-output"}),"\n",(0,o.jsx)(t.p,{children:"The throttle value with 11 bits gives a resolution of 2048. It has been suggested the first values be reserved (possibly for startup tones or commands), so 0 means disarmed. So if 1 to 47 are reserved, and then 48-2047 is the throttle position \u2013 giving 2000 steps of resolution."}),"\n",(0,o.jsx)(t.p,{children:"In the throttle value portion of the frame the most significant bits are first, so the first bit having a value of 1 means the throttle is at least half way, i.e. 1024, the second bit represents 512, the third 256 and so on until bit 11 represents the value of 1. So the bit sequence 11111111111 represents full throttle, and 10000000000 represents half throttle. The following image is a capture of DSHOT600 in action on a BluejayF4:"}),"\n",(0,o.jsx)(t.h3,{id:"dshot-capture",children:"dshot-capture"}),"\n",(0,o.jsx)(t.p,{children:"There is normally a pause between frames of at least 2 microseconds to indicate a frame reset. A reset simply indicates the end of one frame and thus any future bits are the start of a new frame. With DSHOT occurring at the end of a PID loop this pause is actually considerably longer. If DSHOT were to be made to continuously output a signal then this delay would be required."}),"\n",(0,o.jsx)(t.h3,{id:"is-it-the-most-efficient",children:"Is it the most efficient?"}),"\n",(0,o.jsx)(t.p,{children:"It should of course be noted that DSHOT is not the absolute most efficient protocol for representing bit values in a serial stream, but the reason for the approach taken rather than other options is to ensure accuracy in the very noisy environment found on a multi-rotor. That said it is certainly no slouch. It takes it to the current crop, with DSHOT600 being a mere 1 microsecond slower than Multishot at full throttle. Even DSHOT150 is on a par with Oneshot42. The following graph represents the full throttle timing of the current protocols:"}),"\n",(0,o.jsx)(t.p,{children:"DSHOT has no real concept of minimum and maximum durations for timing, it is a digital protocol afterall. A disarmed throttle value of 0 takes the same amount of time to communicate as a full throttle value."}),"\n",(0,o.jsx)(t.h3,{id:"will-my-escs-or-flight-controller-be-supported",children:"Will my ESCs or flight controller be supported?"}),"\n",(0,o.jsx)(t.p,{children:"Work is being done in KISS firmware and in Betaflight to support this new protocol, and so far testing is looking very promising. It is unlikely that F1 processors (Naze, CC3D etc) will be able to support it, due to the direct memory access requirements of the hardware. Those processors just don\u2019t have enough DMA channels available. F3, F4 and F7 all have more than enough. However inside those processors certain mappings exist \u2013 between timers, DMA and the actual pins \u2013 and so it is possible we will find a target where you won\u2019t be able to simply use motor outputs 1 to 4, but may have to move to motors 1, 2, 4 and 5 (as an example). Resource remapping in Betaflight 3.1 when released will make this task nice and easy (aside from any soldering if needed)."}),"\n",(0,o.jsx)(t.p,{children:"For ESCs the hardware requirements will mean BLHeli_s or better. There are also ARM based ESCs, such as KISS 24A RACE, that will support DSHOT or are able to be upgraded to support it. Unfortunately the old ATMEL and slower SILABs based ESCs are unlikely to ever have the power nor timing hardware needed to support DSHOT. Either way it will mean a firmware upgrade, and in some cases this will mean soldering if the ESC does not have a boot loader that allows simplified firmware updates."}),"\n",(0,o.jsx)(t.h3,{id:"ok--so-what-are-the-benefits",children:"Ok \u2013 so what are the benefits?"}),"\n",(0,o.jsx)(t.p,{children:"The key benefit to digital is there is absolutely no increase in value through repeating the same information, more than once. Digital is simply accurate. There is no jitter (variations in throttle value created due to timing). If the signal is corrupted the ESC can detect it through the checksum. Many will have found motor updates of 32khz appear smoother. This is most likely to do with the repeating signal being \u201caveraged\u201d out effectively and thus effectively filtering (smoothing) the jitter. DSHOT eliminates this PWM jitter, and therefore motor updates need not occur anymore frequently than a motor can actually physically adjust \u2013 and make no mistake there is a physical limit as to how quick a motor can change its speed."}),"\n",(0,o.jsx)(t.p,{children:"Another benefit is of course, no calibration required. In the digital world a zero is just that, a zero."}),"\n",(0,o.jsx)(t.p,{children:"So really now it is just a case of rest in peace PWM, for we have a new friend, and that friend goes by the name of DSHOT!"}),"\n",(0,o.jsx)(t.h3,{id:"joe-lucid-took-it-further-and-introduced-bidirectional-dshot",children:"Joe Lucid took it further and introduced bidirectional Dshot"}),"\n",(0,o.jsx)(t.p,{children:"Dshot bidir uses inverted signal levels (idle is 1). FC to ESC uses dshot frames but the lowest 4 bits hold the complement of the other nibbles xor'd together (normal dshot does not complement the xor sum). The ESC detects based on the inversion that telemetry packets have to be sent."}),"\n",(0,o.jsx)(t.p,{children:"30us after receiving the dshot frame the esc responds with a telemetry frame. Logically the telemetry frame is a 16 bit value and the lowest 4 bits hold the complemented xor'd nibbles again."}),"\n",(0,o.jsx)(t.p,{children:"The upper 12 bit contain the eperiod (1/erps) in the following bitwise encoding:"}),"\n",(0,o.jsx)(t.p,{children:"e e e m m m m m m m m m\nThe 9 bit value M needs to shifted left E times to get the period in micro seconds. This gives a range of 1 us to 65408 us. Which translates to a min e-frequency of 15.29 hz or for 14 pole motors 3.82 hz."}),"\n",(0,o.jsx)(t.p,{children:"This 16 bit value is then GCR encoded to a 20 bit value by applying the following map nibble-wise:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"0 -> 19\n1 -> 1b\n2 -> 12\n3 -> 13\n4 -> 1d\n5 -> 15\n6 -> 16\n7 -> 17\n8 -> 1a\n9 -> 09\na -> 0a\nb -> 0b\nc -> 1e\nd -> 0d\ne -> 0e\nf -> 0f\n"})}),"\n",(0,o.jsx)(t.p,{children:"This creates a 20 bit value which has no more than two consecutive zeros. This value is mapped to a new 21 bit value by starting with a bit value of 0 and changing the bit value in the next bit if the current bit in the incoming value is a 1, but repeating the previous bit value otherwise. Example:"}),"\n",(0,o.jsx)(t.p,{children:"1 0 1 1 1 0 0 1 1 0 would become 0 1 1 0 1 0 0 0 1 0 0."}),"\n",(0,o.jsx)(t.p,{children:"This 21 bit value is then sent uninverted at a bitrate of 5/4 * the dshot bitrate. So Dshot 3 uses 375 kbit, dshot 600 uses 750 kbit."}),"\n",(0,o.jsx)(t.p,{children:"The esc needs to be ready after 40us + one dshot frame length to receive the next dshot packet."}),"\n",(0,o.jsxs)(t.p,{children:["See ",(0,o.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Run-length_limited#GCR:_(0,2)_RLL",children:"https://en.wikipedia.org/wiki/Run-length_limited#GCR:_(0,2)_RLL"})," for more details on the GCR encoding."]}),"\n",(0,o.jsxs)(t.p,{children:["See ",(0,o.jsx)(t.a,{href:"https://github.com/betaflight/betaflight/pull/8554",children:"https://github.com/betaflight/betaflight/pull/8554"})]})]})}function c(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},11151:(e,t,i)=>{i.d(t,{Z:()=>r,a:()=>a});var o=i(67294);const s={},n=o.createContext(s);function a(e){const t=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(n.Provider,{value:t},e.children)}}}]);