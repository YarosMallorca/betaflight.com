"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6332],{24024:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>t,default:()=>x,frontMatter:()=>l,metadata:()=>d,toc:()=>c});var r=i(85893),o=i(11151);const l={},t=void 0,d={id:"development/PID-Internals",title:"PID-Internals",description:"IO variables",source:"@site/docs/development/PID-Internals.md",sourceDirName:"development",slug:"/development/PID-Internals",permalink:"/docs/development/PID-Internals",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"development",previous:{title:"Oneshot",permalink:"/docs/development/Oneshot"},next:{title:"PID tuning",permalink:"/docs/development/PID-tuning"}},s={},c=[{value:"IO variables",id:"io-variables",level:3},{value:"PID controller 0, &quot;MultiWii&quot; (default)",id:"pid-controller-0-multiwii-default",level:3},{value:"Leveling term",id:"leveling-term",level:4},{value:"Gyro term",id:"gyro-term",level:4},{value:"Mode dependent mix(yaw is always from gyro)",id:"mode-dependent-mixyaw-is-always-from-gyro",level:5},{value:"Gyro stabilization",id:"gyro-stabilization",level:4}];function a(e){const n={code:"code",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h3,{id:"io-variables",children:"IO variables"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"gyroADC/8192*2000 = deg/s"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"gyroADC/4 ~ deg/s"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"rcCommand"})," - ",(0,r.jsx)(n.code,{children:"<-500 - 500>"})," nominal, but is scaled with ",(0,r.jsx)(n.code,{children:"rcRate/100"}),", max +-1250"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"inclination"})," - in 0.1 degree, roll and pitch deviation from horizontal position\n",(0,r.jsx)(n.code,{children:"max_angle_inclination"})," - in 0.1 degree, default 50 degrees (500)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"axisPID"})," - output to mixer, will be added to throttle(",(0,r.jsx)(n.code,{children:"<1000-2000>"}),"), output range is ",(0,r.jsx)(n.code,{children:"<minthrottle, maxthrottle>"})," (default ",(0,r.jsx)(n.code,{children:"<1150 - 1850>"}),")"]}),"\n",(0,r.jsx)(n.h3,{id:"pid-controller-0-multiwii-default",children:'PID controller 0, "MultiWii" (default)'}),"\n",(0,r.jsx)(n.h4,{id:"leveling-term",children:"Leveling term"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"error = constrain(2*rcCommand[axis], limit +- max_angle_inclination) - inclination[axis]\nPacc = constrain(P8[PIDLEVEL]/100 * error, limit +- 5 * D8[PIDLEVEL])\nIacc = intergrate(error, limit +-10000) * I8[PIDLEVEL] / 4096\n"})}),"\n",(0,r.jsx)(n.h4,{id:"gyro-term",children:"Gyro term"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Pgyro = rcCommand[axis];\nerror = rcCommand[axis] * 10 * 8 / pidProfile->P8[axis] - gyroADC[axis] / 4; (conversion so that error is in deg/s ?)\nIgyro = integrate(error, limit +-16000) / 10 / 8  * I8[axis] / 100 (conversion back to mixer units ?)\n"})}),"\n",(0,r.jsx)(n.p,{children:"reset I term if"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"axis rotation rate > +-64deg/s"}),"\n",(0,r.jsx)(n.li,{children:"axis is YAW and rcCommand>+-100"}),"\n"]}),"\n",(0,r.jsx)(n.h5,{id:"mode-dependent-mixyaw-is-always-from-gyro",children:"Mode dependent mix(yaw is always from gyro)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"HORIZON - proportionally according to max deflection"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"  deflection = MAX(ABS(rcCommand[PITCH]), ABS(rcCommand[ROLL])) / 500 ; limit to 0.0 .. 1.0\n  P = Pacc * (1-deflection) + Pgyro * deflection\n  I = Iacc * (1-deflection) + Igyro * deflection\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"gyro"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"  P = Pgyro\n  I = Igyro\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"ANGLE"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"  P = Pacc\n  I = Iacc\n"})}),"\n",(0,r.jsx)(n.h4,{id:"gyro-stabilization",children:"Gyro stabilization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"P -=  gyroADC[axis] / 4 * dynP8 / 10 / 8\nD = -mean(diff(gyroADC[axis] / 4), over 3 samples) * 3 * dynD8 / 32\n[equivalent to :]\nD = - (gyroADC[axis]/4 - (<3 loops old>gyroADC[axis]/4)) * dynD8 / 32\n"})}),"\n",(0,r.jsx)(n.p,{children:"This can be seen as sum of"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["PI controller (handles rcCommand, HORIZON/ANGLE); ",(0,r.jsx)(n.code,{children:"Igyro"})," is only output based on gyroADC"]}),"\n",(0,r.jsx)(n.li,{children:"PD controller(parameters dynP8/dynD8) with zero setpoint acting on gyroADC"}),"\n"]})]})}function x(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>d,a:()=>t});var r=i(67294);const o={},l=r.createContext(o);function t(e){const n=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);